getServerSideProps 함수를 살펴보자!

console.log 문장을 추가해서 이 함수가 실행될 때 Server side code라는 텍스트가 로깅되도록 함

파일을 저장한 뒤 run npm build 명령어로 이 프로덕션 빌드를 실행하면 언제 코드가 실행되었는지를 확인할 수 있음

터미널 영역을 보면 페이지를 사전 생성(Pre-generate)했다는 로그가 보이는데 여기서 주목할 점은 이전과 똑같은 수의 페이지가 생성됐다는 것

슬래시(/) 뒤에 아무것도 없을 때는 재검증(Revalidation)을 거친 초기 페이지가 있고 그리고 404 오류 코드 페이지와 P1, P2, P3 제품에 대한 제품 페이지도 생성됨

사용자 프로필 페이지가 없는 이유는 람다(Lambda) 기호로 엔드 시그널(End signal)을 표시했기 때문

마찬가지로 [uid].js 파일도 생성되지 않음

람다 기호가 있는 페이지들은 사전 생성하지 않고 서버 측에서만 사전 렌더링됐다는 뜻

사용자 프로필에서 getServerSideProps를 그리고 [uid].js에서는 getServerSideProps를 사용했기 때문에 해당 페이지가 사전 생성되지 않은 것

여기까지 마치고 다시 npm start 명령어를 실행한 뒤 localhost:3000를 불러오면 이런 페이지가 나오고 뒤에 /user-profile을 붙이면 Max라는 텍스트가 출력됨

여기서 npm start로 프로덕션 서버를 실행한 터미널을 확인해 보면 Server side code라는 텍스트가 로깅된 것을 확인할 수 있음

위의 consol.log 객체(Object)의 출력값이 나왔으니 이 코드가 실행됐다는 것을 알 수 있지만 앞서 본 것처럼 이 페이지는 사전 생성되지 않았음

getServerSideProps와 getStaticProps 그리고 getStaticPaths를 비교해 보았음

이 셋의 차이점과 정적(Static)인 사전 생성 그리고 서버에서만 실행되는 서버 측 코드의 차이와 그러한 코드를 사용하는 이유를 잘 숙지해야 함

컴포넌트(Component)에 사용하는 데이터를 서버에서 미리 준비해서 클라이언트에게 완성된 페이지를 제공하면 사용자 경험을 개선할 수 있고 사용자들은 처음부터 완성된 페이지에서 모든 콘텐츠를 이용할 수 있게 됨

그 외에도 검색 엔진 크롤러가 완성된 페이지를 확인해서 검색 엔진 최적화에도 도움이 됨
