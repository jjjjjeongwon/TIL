# 📌 fallback 키가 무엇일까?

**fallback 키**를 사용하면 사전 생성되어야 할 페이지가 많을 때 도움이 됨

현재 프로젝트에는 더미 상품이 세 개밖에 없음 + 파일에서 해당 데이터를 페칭하고 있지도 않음

✔️ **Amazon처럼 상품이 수백만 개인 웹 사이트의 경우**

- 모든 상품을 사전 생성하는 것이 물론 최적의 방법은 아님
- 많은 페이지를 사전 생성하면 시간이 너무 오래 걸리기 때문이죠

✔️ **방문객이 거의 없을 경우**

- 수백 개의 게시물이 있는 블로그를 만들면 그중 한 번도 읽히지 않는 게시물이 있을 수 있음
- 방문객이 거의 없는 페이지의 사전 생성은 시간과 자원 낭비임

## 💡 여기서 폴백(fallback) 기능이 필요함

true로 설정하고 **일부 페이지만 사전 렌더링**할 수 있음

- 상품 ID가 1인 페이지를 사전 렌더링한다고 생각해 보자. 즉 p1은 자주 사용되고 방문객이 많은 페이지라고 생각하고 다른 두 페이지는 사전 생성하지 않는다면, `fallback: true` 이렇게 설정하면 가능
- 이렇게 저장하고 시작 페이지로 돌아가서 Product 3을 클릭하면 아직 페이지가 정상적으로 로딩됨
- 여기서 paths에 추가하지 않아도 작동함. `fallback: true`를 사용하면 여기에 포함되지 않은 페이지라도 즉 **pid 매개변수에 대한 매개변수 값이 없더라도 페이지 방문 시 로딩되는 값이 유효할 수 있도록 NextJS에 요청**할 수 있으니까!
  - 다만 사전에 생성되는 건 아니고 요청이 서버에 도달하는 순간 시점에 생성되는 것
- 이런 식으로 방문율이 높은 페이지를 사전 생성할 수 있게 되며 방문이 적은 페이지를 서버에 생성하는 것을 미뤄서 필요한 경우에만 사전 생성되게 할 수 있음
  ```jsx
  export async function getStaticPaths() {
    return {
      paths: [{ params: { pid: "p1" } }],
      fallback: true,
    };
  }
  ```

### 🚫 문제가 한가지 있음

> 링크를 클릭하지 않고 직접 URL에 직접 입력하여 이 페이지에 새로운 요청을 보내면 에러가 발생하게 됨 'undefined 프로퍼티의 이름을 읽을 수 없습니다'라고 뜸

에러의 이유는 **동적 사전 생성 기능이 즉시 끝나지 않기 때문**

따라서 **fallback 기능을 쓰려면 컴포넌트에서 폴백 상태를 반환할 수 있게 해줘야 함**

- `if (!loadedProduct)`로 사전 생성할 부분이 존재하는지 확인하고 만약 존재하지 않는다면 Loading... 같은 내용을 반환하게 만들면 됨

```jsx
function ProductDetailPage(props) {
  const { loadedProduct } = props;

    **if (!loadedProduct) {
      return <p>Loading...</p>;
    }**
  return (
    <Fragment>
      <h1>{loadedProduct.title}</h1>
      <p>{loadedProduct.description}</p>
    </Fragment>
  );
}
```

이제 새로 고침하면 짧게 Loading이 나타나고, 로딩이 완료되면 NextJS가 자동으로 데이터를 제공

- 이 기능은 **useEffect와 setState를 사용하는 표준 React 솔루션과 비슷하지만 간단**!
- 단지 프로퍼티를 통해 얻고 if()로 존재를 확인해서 없는 경우에는 폴백 콘텐츠가 나오게 하면 되는 것. 존재할 경우 NextJS가 자동으로 컴포넌트 페이지를 업데이트하고 일반 콘텐츠를 반환하는 것

따라서 페이지를 새로 고침하면 결국 성공적으로 로딩이 됨 폴백 기능 덕분에!

폴백을 true나 false로 설정하지 않는 대신 `blocking 문자열` 값으로 설정할 경우 컴포넌트에서 폴백 확인을 할 필요가 없음

그러니 해당 부분을 주석 처리하고 보면 페이지가 서비스를 제공하기 전에 서버에 완전히 사전 생성되도록 NextJS가 기다림. 그러면 페이지 방문자가 응답받는 시간은 길어지지만 수신된 응답은 종료될 것

- 다시 새로 고침해도 시간이 걸릴 뿐 잘 작동함

### 📎 애플리케이션에 필요한 접근 방법은 선택에 달려있음

- 빠르게 무엇인가를 보여주는 게 더 중요할 때가 있음
  - ex. 페이지 생성과 데이터 페칭 시간이 오래 걸릴 경우
- 기다리는 게 중요할 때도 있음
  - ex. 방문자에게 불완전한 페이지를 보여주고 싶지 않을 경우
  - 그런 경우 blocking과 같은 문자열이 나을 수 있음
