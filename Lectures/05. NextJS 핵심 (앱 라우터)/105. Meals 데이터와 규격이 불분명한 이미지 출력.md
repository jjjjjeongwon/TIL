시작 페이지를 마무리하였으니

이제 다음 단계로 이 커뮤니티 페이지를 작업하겠습니다

이 페이지에서는 꽤 명확합니다

저는 그냥 임시 컨텐츠로

채우고 싶습니다

따라서 첨부된 것에서

완성된 page.js 파일을 찾을 수 있을 것입니다

그리고 그것으로 여러분의 것을 대체합니다

따라서 여러분의 community page.js 파일을

첨부된 것에서 찾은 것으로 대체합니다

또 여러분은 page.module.css 파일도 찾을 수 있을 것입니다

이것을 community의 page.js 파일 옆에

추가하여

요구된 스타일일들을 가능하게 합니다

이제 이 page.js 파일에서

여기에 커뮤니티 컴포넌트 함수가 내보내기된 것을 확인할 수 있습니다

이 컴포넌트에서

저는 몇 임시 텍스트를 출력하고

끝에 몇 가지의 이미지를 출력합니다

이제 모든 것을 저장하면

커뮤니티 페이지는 다음과 같이 보여지고

간단히 임시 대체 텍스트를 출력하였습니다

물론 이 전체 데모 프로젝트의 메인 로직은

meals 와 관련되어 있기에

거기가 우리가 데이터를 가져오고

또 새로운 meals를 계속해서 더하는 곳입니다

그것은 곧 살펴보도록 하겠습니다

그래서 이것이 제가 여러분에게 임시 컨텐츠를 제공한 이유입니다

이제 커뮤니티 페이지가 채워졌으니

특별히 헤더 또는

내비게이션에 있어

제가 개선하고 싶은 것이 한 가지 있습니다

우리는 현재 어떤 페이지가 활성화되어있는 지 알 수 없습니다

저는 커뮤니티 페이지에 있지만

여기 이 링크는 제가 이곳에 있을 때 하이라이트 되어있지 않기에

이것이 하이라이트되면 더 좋을 것 입니다

이것을 수행하기 위해 우리는 다시

main header 컴포넌트로 돌아갑니다

여기에 이 내비게이션이 있고

우리는 이 링크를 조금 수정합니다

정확하게는

이 링크에 조건부적으로 클래스를 추가하고 싶습니다

이 링크가 연결되는 페이지가 활동 중인지 아닌지에

따라서 말입니다

이를 위해 이 main-header.module.css 파일에서

저는 active 스타일링을 위해

링크에 더해질 수 있는

css 클래스를 준비했습니다

따라서 우리가 여기에서 할 것은

이것이 active (활동 중)이라고 표시되어야 할지 아닌지를 찾는 것입니다

그리고 우리는 이것을 현재 경로의 이름을 확인하여

어떤 경우인지를 확인할 수 있습니다

따라서 도메인 다음 부분을 확인하면 됩니다

예를 들어서 이 커뮤니티 링크에서

경로는 /community 입니다

따라서 우리는 경로가 이 경로와 같다면

여기 링크는 활동 중으로 표시되어야 한다는 것을 알 수 있습니다

meals 페이지에서는

그리고 관련된 페이지에서는

/meals나 /mealsshare

혹은 다른 중첩된 페이지에 있을 때

활동 중으로 표시되어야 합니다

따라서 현재 활동 경로가 /meals로 시작한다면 말입니다

따라서 우리는 그냥 현재

활동 경로를 파악하면 됩니다

그리고 감사하게도 Next.js가 usePathName 훅을 주기 때문에

꽤 명확합니다

이것은 next/navigation으로부터 불러올 수 있습니다

이 훅은 현재 활동 경로를

도메인 다음 부분에 줍니다

그 경로가 사용 가능한 상태에서

usePathname에서 가져오는 경로가

/meals로 시작하는 경우에는

meals링크를 활성으로 설정할 수 있습니다

따라서 이 링크는 식사 페이지나

일부 중첩된 페이지에 있더라도

활성으로 표시됩니다

이것이 바로 startsWith를 사용하는 이유입니다

이 경우에 true라면

active css 클래스를 추가하고 싶습니다

그러나 우리가 css 모듈을 사용하기에

다음과 같이가 아닌

이렇게 입니다

그렇지 않다면 undefined를 클래스로 추가하여

아무 클래스도 추가되지 않도록 합니다

이제 우리는 이 과정을 다른 링크에도 반복할 수 있고

간단히 저기 className 코드를 복사합니다

여기서 저는 경로가 community로

시작하는지

혹은 우리가 여기에서 아무런 중첩된 페이지가 없기에

경로가 /community와 동일한지 확인하고 싶습니다

그리고 그에 따라 active 클래스를 추가하거나

undefined를 추가합니다

이렇게 하더라도

에러가 뜰 것입니다

왜냐하면 usePathname 또한

오직 클라이언트 컴포넌트에서만 작동하기 때문입니다

그리고 이것은 Next.js의 편리한 기능 중 하나입니다

여러분이 서버 컴포넌트 내에서

서버 컴포넌트에서 작동되지 않는

기능을 사용할 때 이를 알려줌으로써

여러분은 use client 지시어를 추가하면 됩니다

따라서 여기서 수정할 것은

이 헤더 위에 use client 지시어를 추가하는 것입니다

그러나 여기서 기억해야 할 것이 있습니다

여러분이 이것을 하는 동안

에러가 사라지고

여러분은 이제 활동중인 링크가 하이라이트 되는 것을 볼 수 있습니다

이게 작동되는 동안

일반적으로 컴포넌트 트리를

가능한 아래로 내려가서

필요한 컴포넌트만 클라이언트 컴포넌트로 변환하여

대부분의 컴포넌트가

서버 컴포넌트로 유지되고

대부분의 컴포넌트에서

서버 컴포넌트의

이점을 잃지 않도록 하려면

컴포넌트 트리를 가능한 아래로 내려가서

useClient를 추가하는 것이 좋습니다

따라서 여기

이 header 컴포넌트가 상당히 많은

클라이언트 컴포넌트에서는 필요없는 마크업을 포함하고 있기에

저는 다른 접근을 시도하겠습니다

새로운 컴포넌트 파일

nav-link.js 라는 파일을 추가합니다

그리고 옆에 nav-link.module.css 파일을 추가하겠습니다

그리고 여기서 자바스크립트 파일에서의 목적은

NavLinkf라 불리는

컴포넌트 함수를 내보내기 하는 것입니다

이것은 단순히 NavLink를 출력합니다

따라서 main-header.js 파일에서

저는 단순히 이 링크만을 가지고 옵니다

잘라서

여기로 반환합니다

이를 위해 우리는 무조건 Link 컴포넌트를

next/link로부터 불러오기 해야 하며

물론 NavLink를 구성 가능하게 만들어야 합니다

따라서 여기 저는 href 속성을 가지고 오고

그리고 실제로 링크 사이에 출력되는 텍스트에 대한 내용은

children 속성을 사용하겠습니다.

여기 children을 사용하고

여기 href를 사용합니다

그리고 여기 또한 href 속성을 활용하여

active 링크인지 아닌지를 확인합니다

물론 여기에서 경로가 이용 가능하려면

전에 보여주었듯이

usePathname 훅을 사용해야만 합니다

따라서 우리는 경로를 얻을 수 있도록

이를 클라이언트 컴포넌트로

변환해야 합니다

따라서 다음과 같이 useClient를 추가합니다

하지만 이제 오직 이 컴포넌트만이

클라이언트 측에서 렌더링 되는

작은 조각의 마크업입니다

우리는 이제 main-header.js 파일로 돌아가서

여기의 use client와

usePathname import와

usePathname usage를 지웁니다

왜냐하면 이제 우리는 간단히

새로이 추가된 NavLink 컴포넌트를 사용할 수 있기 때문입니다

따라서 저는 이것을

NavLink 컴포넌트 파일로부터 불러오기 하고

다음과 같이 출력합니다

그리고 다음과 같이 서버 컴포넌트 내에서

use client 컴포넌트를 사용할 수 있습니다

전에 이미지 슬라이드쇼에서 했었고

우리는 이것을 NavLink에서 다시 하는 것입니다

NavLink는 여기 태그 사이의

링크 텍스트를 가지고

이 상황에서는 Browse Meals 입니다

우리는 여기 href 속성을 /meals로 설정합니다

이제 당연히 여기를 커뮤니티를 위해

다 사용할 수 있습니다

여기 우리의 Foodies Community 또한

NavLink로 바꼈습니다

단지 우리는 /community로 지정하는지

확인하면 됩니다

이로써

메인 헤더 컴포넌트가

클라이언트 컴포넌트로 변환되지 않도록 하고

따라서 여전히 서버에서 렌더링되도록 보장했습니다.

대신에 이 작은 부분만이

클라이언트에 렌더링됩니다

당연히 이제 여기 저는 classes가 정의되지 않았다는

에러를 받습니다

왜냐하면 NavLink에서 저는 이 classes 객체가 이용 가능하지 않았음에도

classes.active를 언급했습니다

이것을 해결하기 위해

간단히 여기에 import를 추가하여

import classes from nav-link.module.css 합니다

당연히 이때 이것은 빈 css 파일이기에

우리는

main-header.module.css 파일로 가서

여기의 active 클래스를 가져와

이 nav-link.module.css 파일에 추가해야 합니다

또한 이 링크와 관련된 스타일을 잡고

잘라서

nav-link.module 파일에 추가한 후

anchor (앵커) 요소로부터

선택자를 바꿉니다

그것을 어떤 nav 클래스를 가진 요소로

중첩시켜 링크하거나

여기와 여기처럼

클래스를 가진 요소로 링크할 수 있습니다

이렇게 하면 nav-link.js로 돌아가

그 링크 클래스들을 여기 링크에 추가할 수 있습니다

그래서 link와 active 클래스가 추가된 경우

또는 그냥 link인 경우가 됩니다.

이를 위해 여기를

템플릿 리터럴 문자열로 변경하여

여기에 classes.link와 classes.active가

링크에 설정되도록 하는 동적 값을

쉽게 삽입할 수 있는 곳이 있습니다

이 값들은 문자열로 변환됩니다

그렇지 않다면 만약 링크가 활동 중이지 않을 때

그냥 classes.link를 다음과 같이 추가합니다

이제 이것이 저의 조정된 NavLink입니다

이로써 모든 것을 작동하지만

이제 오직 NavLinks 만이 클라이언트에 렌더링됩니다

그리고 모든 나머지 것들은 여전히 서버에 렌더링됩니다
